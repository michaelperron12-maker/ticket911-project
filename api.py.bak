#!/usr/bin/env python3
"""
FightMyTicket — API Flask v2
Pipeline 26 agents / 4 phases / upload fichiers / PDF rapport
Port: 8912 (nginx proxy sur 8911)
"""

import json
import time
import os
import uuid
import hashlib
from datetime import datetime
from flask import Flask, request, jsonify, send_from_directory, send_file, abort, make_response
from flask_cors import CORS
from werkzeug.utils import secure_filename
import psycopg2

# Load .env
try:
    from dotenv import load_dotenv
    load_dotenv(os.path.join(os.path.dirname(os.path.abspath(__file__)), ".env"))
except ImportError:
    pass

import sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from agents.orchestrateur import Orchestrateur
from agents.base_agent import PG_CONFIG, DATA_DIR

app = Flask(__name__, static_folder="web", static_url_path="")
CORS(app)
app.config["MAX_CONTENT_LENGTH"] = 20 * 1024 * 1024  # 20 MB max

# Dossiers
UPLOAD_DIR = os.path.join(DATA_DIR, "uploads")
RAPPORT_DIR = os.path.join(DATA_DIR, "rapports")
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(RAPPORT_DIR, exist_ok=True)

ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif", "webp", "pdf", "heic"}

# Init orchestrateur (une seule fois)
orchestrateur = None


def get_orchestrateur():
    global orchestrateur
    if orchestrateur is None:
        orchestrateur = Orchestrateur()
    return orchestrateur


def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


def get_client_folder(dossier_uuid):
    """Cree un dossier client unique pour stockage"""
    folder = os.path.join(UPLOAD_DIR, dossier_uuid)
    os.makedirs(folder, exist_ok=True)
    return folder


# ─── PAGE WEB ─────────────────────────────────
@app.route("/")
def index():
    resp = make_response(send_from_directory(".", "scanner.html"))
    resp.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
    resp.headers["Pragma"] = "no-cache"
    resp.headers["Expires"] = "0"
    return resp


# ─── UPLOAD FICHIERS ──────────────────────────
@app.route("/api/upload", methods=["POST"])
def upload_files():
    """Upload ticket photo + preuves — stocke dans dossier UUID"""
    dossier_uuid = request.form.get("dossier_uuid", str(uuid.uuid4())[:8].upper())
    folder = get_client_folder(dossier_uuid)

    uploaded = []
    errors = []

    for key in request.files:
        file = request.files[key]
        if file and file.filename:
            if allowed_file(file.filename):
                safe_name = secure_filename(file.filename)
                # Prefixer avec type (ticket, preuve, dashcam)
                file_type = key.replace("[]", "")  # ticket_photo, evidence_1, dashcam, etc.
                final_name = f"{file_type}_{safe_name}"
                filepath = os.path.join(folder, final_name)
                file.save(filepath)
                uploaded.append({
                    "name": final_name,
                    "type": file_type,
                    "size": os.path.getsize(filepath),
                    "path": filepath
                })
            else:
                errors.append(f"{file.filename}: type non supporte")

    return jsonify({
        "success": True,
        "dossier_uuid": dossier_uuid,
        "uploaded": len(uploaded),
        "files": uploaded,
        "errors": errors
    })


# ─── ANALYSE COMPLETE (26 agents) ─────────────
@app.route("/api/analyze", methods=["POST"])
def analyze():
    """Analyse complete — pipeline 26 agents / 4 phases"""
    content_type = request.content_type or ""

    # Support multipart (avec fichiers) ou JSON
    if "multipart" in content_type:
        ticket_json = request.form.get("ticket", "{}")
        try:
            ticket = json.loads(ticket_json)
        except json.JSONDecodeError:
            ticket = {}

        client_info_json = request.form.get("client_info", "{}")
        try:
            client_info = json.loads(client_info_json)
        except json.JSONDecodeError:
            client_info = {}

        # Upload des fichiers
        dossier_uuid = str(uuid.uuid4())[:8].upper()
        folder = get_client_folder(dossier_uuid)
        image_path = None
        evidence_photos = []

        for key in request.files:
            file = request.files[key]
            if file and file.filename and allowed_file(file.filename):
                safe_name = secure_filename(file.filename)
                filepath = os.path.join(folder, f"{key}_{safe_name}")
                file.save(filepath)
                if key in ("ticket_photo", "ticket"):
                    image_path = filepath
                elif key.startswith("evidence") or key.startswith("photo") or key.startswith("preuve"):
                    evidence_photos.append(filepath)

        # Temoignage et temoins (depuis form data)
        temoignage = request.form.get("temoignage", "")
        temoins_json = request.form.get("temoins", "[]")
        try:
            temoins = json.loads(temoins_json)
        except json.JSONDecodeError:
            temoins = []
    else:
        data = request.get_json()
        if not data:
            return jsonify({"error": "JSON ou multipart requis"}), 400
        ticket = data.get("ticket", data)
        client_info = data.get("client_info", {})
        image_path = None
        evidence_photos = []
        temoignage = data.get("temoignage", "")
        temoins = data.get("temoins", [])

    if not ticket.get("infraction") and not image_path:
        return jsonify({"error": "Photo du ticket ou champ 'infraction' requis"}), 400

    try:
        orch = get_orchestrateur()
        rapport = orch.analyser_ticket(
            ticket, image_path=image_path, client_info=client_info,
            evidence_photos=evidence_photos if evidence_photos else None,
            temoignage=temoignage if temoignage else None,
            temoins=temoins if temoins else None)

        dossier_uuid = rapport.get("dossier_uuid", "")

        # Extraire l'analyse complete depuis le rapport sauvegardé en DB
        analyse_data = None
        try:
            conn = psycopg2.connect(**PG_CONFIG)
            cur = conn.cursor()
            cur.execute("SELECT analyse_json FROM analyses_completes WHERE dossier_uuid = %s",
                      (dossier_uuid,))
            row = cur.fetchone()
            if row and row[0]:
                analyse_data = row[0] if isinstance(row[0], dict) else json.loads(row[0])
            conn.close()
        except Exception:
            pass

        return jsonify({
            "success": True,
            "dossier_uuid": dossier_uuid,
            "score": rapport.get("score_final", 0),
            "confiance": rapport.get("confiance", 0),
            "recommandation": rapport.get("recommandation", "?"),
            "juridiction": rapport.get("juridiction", "?"),
            "temps": rapport.get("temps_total", 0),
            "erreurs": rapport.get("nb_erreurs", 0),
            "phases": {
                phase: {
                    agent: (d.get("status", "OK") if isinstance(d, dict) and "status" in d else "OK")
                    for agent, d in agents.items()
                } if isinstance(agents, dict) else {}
                for phase, agents in rapport.get("phases", {}).items()
            },
            "analyse": analyse_data,
            "rapport_client": rapport.get("phases", {}).get("livraison", {}).get("rapport_client"),
            "procedure": rapport.get("phases", {}).get("analyse", {}).get("procedure"),
            "points": rapport.get("phases", {}).get("analyse", {}).get("points"),
            "supervision": rapport.get("phases", {}).get("livraison", {}).get("supervision"),
            "precedents_trouves": rapport.get("phases", {}).get("analyse", {}).get("precedents", {}).get("nb", 0) if isinstance(rapport.get("phases", {}).get("analyse", {}).get("precedents"), dict) else 0,
            "lois_trouvees": rapport.get("phases", {}).get("analyse", {}).get("lois", {}).get("nb", 0) if isinstance(rapport.get("phases", {}).get("analyse", {}).get("lois"), dict) else 0,
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


# ─── RAPPORT PDF ───────────────────────────────
@app.route("/api/rapport/<dossier_uuid>")
def get_rapport_pdf(dossier_uuid):
    """Genere et retourne le rapport PDF 9 pages"""
    # Chercher l'analyse en DB
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()
        cur.execute("""SELECT ticket_json, analyse_json, rapport_client_json,
                            rapport_avocat_json, procedure_json, points_json,
                            lois_json, precedents_json, cross_verification_json,
                            supervision_json, score_final, confiance, recommandation,
                            juridiction, temps_total, created_at
                     FROM analyses_completes WHERE dossier_uuid = %s""", (dossier_uuid,))
        row = cur.fetchone()
        conn.close()

        if not row:
            return jsonify({"error": f"Dossier {dossier_uuid} non trouve"}), 404

        # Parse les JSONs
        data = {
            "ticket": json.loads(row[0] or "{}"),
            "analyse": json.loads(row[1] or "{}"),
            "rapport_client": json.loads(row[2] or "{}"),
            "rapport_avocat": json.loads(row[3] or "{}"),
            "procedure": json.loads(row[4] or "{}"),
            "points": json.loads(row[5] or "{}"),
            "lois": json.loads(row[6] or "[]"),
            "precedents": json.loads(row[7] or "[]"),
            "cross_verification": json.loads(row[8] or "{}"),
            "supervision": json.loads(row[9] or "{}"),
            "score_final": row[10],
            "confiance": row[11],
            "recommandation": row[12],
            "juridiction": row[13],
            "temps_total": row[14],
            "created_at": row[15],
            "dossier_uuid": dossier_uuid,
        }

        # Generer le PDF
        pdf_path = _generer_pdf(data)
        if pdf_path and os.path.exists(pdf_path):
            return send_file(pdf_path, mimetype="application/pdf",
                             as_attachment=True,
                             download_name=f"FightMyTicket-{dossier_uuid}.pdf")
        else:
            # Fallback: retourner le HTML
            html = _generer_html_rapport(data)
            return html, 200, {"Content-Type": "text/html; charset=utf-8"}

    except Exception as e:
        return jsonify({"error": str(e)}), 500


def _generer_pdf(data):
    """Genere le PDF via WeasyPrint"""
    try:
        from weasyprint import HTML
        html_content = _generer_html_rapport(data)
        pdf_path = os.path.join(RAPPORT_DIR, f"FightMyTicket-{data['dossier_uuid']}.pdf")
        HTML(string=html_content).write_pdf(pdf_path)
        return pdf_path
    except ImportError:
        return None
    except Exception:
        return None


def _generer_html_rapport(data):
    """Genere le rapport HTML 9 pages"""
    ticket = data.get("ticket", {})
    analyse = data.get("analyse", {})
    rapport_client = data.get("rapport_client", {})
    rapport_avocat = data.get("rapport_avocat", {})
    procedure = data.get("procedure", {})
    points = data.get("points", {})
    lois = data.get("lois", [])
    precedents = data.get("precedents", [])
    cross_verif = data.get("cross_verification", {})
    supervision = data.get("supervision", {})
    uuid_str = data.get("dossier_uuid", "?")
    score = data.get("score_final", 0)
    confiance = data.get("confiance", 0)
    reco = data.get("recommandation", "?")
    juridiction = data.get("juridiction", "?")
    date_str = data.get("created_at", datetime.now().isoformat())[:10]

    # Couleur score
    if score >= 70:
        score_color = "#27ae60"
    elif score >= 40:
        score_color = "#f39c12"
    else:
        score_color = "#e74c3c"

    # Arguments
    args_html = ""
    arguments = analyse.get("arguments", [])
    for i, arg in enumerate(arguments, 1):
        args_html += f"<li>{arg}</li>"

    # Precedents
    prec_html = ""
    for p in precedents[:8]:
        prec_html += f"""<tr>
            <td>{p.get('citation', '?')[:60]}</td>
            <td>{p.get('tribunal', '?')}</td>
            <td>{p.get('date', '?')}</td>
            <td>{p.get('resultat', '?')}</td>
            <td>{p.get('score', 0)}%</td>
        </tr>"""

    # Lois
    lois_html = ""
    for l in lois[:6]:
        lois_html += f"""<tr>
            <td>{l.get('article', '?')}</td>
            <td>{l.get('juridiction', '?')}</td>
            <td>{l.get('texte', '')[:200]}</td>
        </tr>"""

    # Etapes procedure
    etapes_html = ""
    for etape in (procedure.get("etapes", []) if procedure else []):
        etapes_html += f"<li>{etape}</li>"

    # Moyens de defense (avocat)
    moyens_html = ""
    for m in rapport_avocat.get("moyens_de_defense", []):
        moyens_html += f"<li>{m}</li>"

    # Faiblesses
    faiblesses_html = ""
    for f in rapport_avocat.get("faiblesses_dossier", []):
        faiblesses_html += f"<li>{f}</li>"

    # Economie
    eco = points.get("economie_si_acquitte", {}) if points else {}

    # Prochaines etapes client
    etapes_client_html = ""
    for e in rapport_client.get("prochaines_etapes", []):
        etapes_client_html += f"<li>{e}</li>"

    return f"""<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<style>
    @page {{ size: A4; margin: 1.5cm 1.5cm 1.2cm 1.5cm; }}
    body {{ font-family: 'Helvetica Neue', Arial, sans-serif; color: #1e3a5f; font-size: 9.5pt; line-height: 1.4; }}
    h1 {{ color: #1e3a5f; font-size: 16pt; border-bottom: 2px solid #2563eb; padding-bottom: 4px; margin: 14px 0 8px; }}
    h2 {{ color: #1e3a5f; font-size: 12pt; border-bottom: 1px solid #d4a843; padding-bottom: 3px; margin: 12px 0 6px; }}
    h3 {{ color: #2563eb; font-size: 10pt; margin: 8px 0 4px; }}
    .header {{ text-align: center; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 2px solid #2563eb; }}
    .score-box {{ background: {score_color}; color: white; padding: 10px 20px; border-radius: 8px;
                   display: inline-block; font-size: 20pt; font-weight: bold; }}
    .info-grid {{ display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin: 8px 0; }}
    .info-grid-4 {{ display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 6px; margin: 8px 0; }}
    .info-item {{ background: #f8f9fa; padding: 5px 8px; border-radius: 4px; font-size: 8.5pt; }}
    .info-label {{ font-weight: bold; color: #666; font-size: 7.5pt; text-transform: uppercase; }}
    table {{ width: 100%; border-collapse: collapse; margin: 6px 0; font-size: 8.5pt; }}
    th {{ background: #1e3a5f; color: white; padding: 5px 6px; text-align: left; font-size: 8pt; }}
    td {{ padding: 4px 6px; border-bottom: 1px solid #eee; }}
    tr:nth-child(even) {{ background: #f8f9fa; }}
    .reco-box {{ background: #e8f5e9; border-left: 3px solid #27ae60; padding: 8px 10px; margin: 8px 0; }}
    .warn-box {{ background: #fff3e0; border-left: 3px solid #f39c12; padding: 8px 10px; margin: 8px 0; }}
    .section {{ page-break-inside: avoid; }}
    .page-break {{ page-break-before: always; }}
    .footer {{ text-align: center; color: #999; font-size: 7pt; margin-top: 15px;
               border-top: 1px solid #ddd; padding-top: 5px; }}
    ul, ol {{ padding-left: 18px; margin: 4px 0; }}
    li {{ margin-bottom: 3px; }}
    .eco-total {{ font-size: 14pt; color: #27ae60; font-weight: bold; }}
    .disclaimer {{ font-size: 7.5pt; color: #999; text-align: center; margin-top: 10px; }}
</style>
</head>
<body>

<!-- COUVERTURE + RESUME -->
<div class="header">
    <h1 style="border:none;font-size:20pt;margin:0;">FIGHTMYTICKET</h1>
    <p style="font-size: 10pt; color: #666; margin: 2px 0;">Rapport d'analyse juridique par intelligence artificielle</p>
    <p style="font-size: 9pt; margin: 2px 0;">Dossier <strong>#{uuid_str}</strong> | {date_str} | {juridiction}</p>
    <div style="margin: 10px 0 5px;">
        <div class="score-box">{score}%</div>
        <span style="font-size: 9pt; color: #666; margin-left: 10px;">Score de contestation</span>
    </div>
</div>

<div class="info-grid-4">
    <div class="info-item"><span class="info-label">Infraction</span><br>{ticket.get('infraction', '?')}</div>
    <div class="info-item"><span class="info-label">Amende</span><br>{ticket.get('amende', '?')}</div>
    <div class="info-item"><span class="info-label">Points</span><br>{ticket.get('points_inaptitude', 0)}</div>
    <div class="info-item"><span class="info-label">Juridiction</span><br>{juridiction}</div>
    <div class="info-item"><span class="info-label">Lieu</span><br>{ticket.get('lieu', '?')}</div>
    <div class="info-item"><span class="info-label">Date</span><br>{ticket.get('date', '?')}</div>
    <div class="info-item"><span class="info-label">Recommandation</span><br><strong>{reco.upper()}</strong></div>
    <div class="info-item"><span class="info-label">Confiance</span><br>{confiance}%</div>
</div>

<div class="reco-box">
    <h3 style="margin:0 0 3px;">Verdict</h3>
    <p style="margin:0;">{rapport_client.get('verdict', reco)}</p>
</div>

<div class="section">
    <h2>Resume</h2>
    <p>{rapport_client.get('resume', 'Analyse en cours...')}</p>
</div>

<div class="section">
    <h2>Prochaines etapes</h2>
    <ol>{etapes_client_html}</ol>
</div>

{f'<div class="warn-box"><strong>Attention:</strong> {rapport_client.get("attention", "")}</div>' if rapport_client.get("attention") else ""}

<div class="info-grid">
    <div class="info-item"><span class="info-label">Economie potentielle</span><br><span class="eco-total">${eco.get('total', 0):,}</span></div>
    <div class="info-item"><span class="info-label">Amende: ${eco.get('amende', 0)}</span><br>Assurance (3 ans): ${eco.get('assurance_3ans', eco.get('cout_supplementaire_3ans', 0)):,}</div>
</div>

<!-- PAGE 2: Defense + Lois + Jurisprudence -->
<div class="page-break"></div>

<div class="section">
    <h1>Arguments de defense</h1>
    <ol>{args_html}</ol>
</div>

<div class="section">
    <h2>Strategie recommandee</h2>
    <p>{analyse.get('strategie', analyse.get('explication', ''))}</p>
</div>

<div class="section">
    <h2>Lois applicables</h2>
    <table>
        <tr><th>Article</th><th>Juridiction</th><th>Texte</th></tr>
        {lois_html}
    </table>
</div>

<div class="section">
    <h2>Jurisprudence pertinente ({len(precedents)} decisions)</h2>
    <table>
        <tr><th>Citation</th><th>Tribunal</th><th>Date</th><th>Resultat</th><th>%</th></tr>
        {prec_html}
    </table>
</div>

<!-- PAGE 3: Procedure + Points + Rapport avocat -->
<div class="page-break"></div>

<div class="section">
    <h1>Procedure judiciaire</h1>
    <div class="info-grid">
        <div class="info-item"><span class="info-label">Tribunal</span><br>{procedure.get('tribunal', '?') if procedure else '?'}</div>
        <div class="info-item"><span class="info-label">Jours restants</span><br>{procedure.get('jours_restants', '?') if procedure else '?'}</div>
    </div>
    <h3>Etapes</h3>
    <ol>{etapes_html}</ol>
</div>

<div class="section">
    <h2>Impact points et assurance</h2>
    <div class="info-grid">
        <div class="info-item"><span class="info-label">Points</span><br>{points.get('points_demerite', points.get('points_dmv', '?')) if points else '?'}</div>
        <div class="info-item"><span class="info-label">Augmentation assurance</span><br>{points.get('impact_assurance', {{}}).get('note', '?') if points else '?'}</div>
    </div>
</div>

<div class="section">
    <h2>Rapport technique (avocat)</h2>
    <p><em>{rapport_avocat.get('resume_technique', '')}</em></p>

    <h3>Moyens de defense</h3>
    <ol>{moyens_html}</ol>

    <h3>Faiblesses du dossier</h3>
    <ul>{faiblesses_html}</ul>

    <h3>Fondement legal</h3>
    <p>{rapport_avocat.get('fondement_legal', '')}</p>
</div>

<!-- Certification -->
<div style="margin-top: 15px; padding-top: 10px; border-top: 2px solid #2563eb;">
    <h2 style="border:none;">Certification</h2>
    <div class="info-grid-4">
        <div class="info-item"><span class="info-label">Dossier</span><br>#{uuid_str}</div>
        <div class="info-item"><span class="info-label">Qualite</span><br>{supervision.get('score_qualite', '?')}%</div>
        <div class="info-item"><span class="info-label">Decision</span><br>{supervision.get('decision', '?')}</div>
        <div class="info-item"><span class="info-label">Agents</span><br>{supervision.get('agents_verifies', '?')}</div>
    </div>
</div>

<div class="disclaimer">
    <p><strong>Ce rapport a ete genere automatiquement par FightMyTicket</strong><br>
    Analyse par 26 agents IA specialises | {len(lois)} articles de loi | {len(precedents)} precedents<br>
    Ce rapport ne constitue pas un avis juridique. Consultez un avocat pour des conseils personnalises.</p>
</div>

<div class="footer">
    <p>FightMyTicket par SeoAI | fightmyticket.ca | {datetime.now().year}</p>
</div>

</body>
</html>"""


# ─── API ENDPOINTS EXISTANTS ──────────────────
@app.route("/api/health")
def health():
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM jurisprudence")
        nb_juris = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM lois_articles")
        nb_lois = cur.fetchone()[0]
        conn.close()
        return jsonify({
            "status": "ok",
            "version": "2.0-pg",
            "agents": 26,
            "jurisprudence": nb_juris,
            "lois": nb_lois,
            "timestamp": datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({"status": "error", "error": str(e)}), 500


@app.route("/api/stats")
def stats():
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM jurisprudence")
        total = cur.fetchone()[0]
        cur.execute("SELECT province, COUNT(*) FROM jurisprudence GROUP BY province")
        par_juridiction = {row[0] or "N/A": row[1] for row in cur.fetchall()}
        cur.execute("SELECT resultat, COUNT(*) FROM jurisprudence GROUP BY resultat")
        par_resultat = {row[0] or "N/A": row[1] for row in cur.fetchall()}
        cur.execute("SELECT COUNT(*) FROM lois_articles")
        nb_lois = cur.fetchone()[0]
        cur.execute("SELECT COUNT(*) FROM analyses_completes")
        nb_analyses = cur.fetchone()[0]
        conn.close()
        return jsonify({
            "jurisprudence_total": total,
            "par_juridiction": par_juridiction,
            "par_resultat": par_resultat,
            "lois_indexees": nb_lois,
            "analyses_effectuees": nb_analyses,
            "version": "2.0 (26 agents)"
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route("/api/results")
def results():
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()
        cur.execute("""SELECT id, dossier_uuid, score_final, confiance, recommandation,
                            juridiction, temps_total, created_at
                     FROM analyses_completes ORDER BY id DESC LIMIT 20""")
        rows = cur.fetchall()
        conn.close()
        return jsonify([{
            "id": r[0], "dossier_uuid": r[1], "score": r[2], "confiance": r[3],
            "recommandation": r[4], "juridiction": r[5], "temps": r[6], "date": r[7]
        } for r in rows])
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@app.route("/api/dossier/<dossier_uuid>")
def get_dossier(dossier_uuid):
    """Retourne les donnees completes d'un dossier"""
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()
        cur.execute("""SELECT ticket_json, analyse_json, rapport_client_json,
                            rapport_avocat_json, procedure_json, points_json,
                            lois_json, precedents_json, cross_verification_json,
                            supervision_json, score_final, confiance, recommandation,
                            juridiction, temps_total, created_at
                     FROM analyses_completes WHERE dossier_uuid = %s""", (dossier_uuid,))
        row = cur.fetchone()
        conn.close()

        if not row:
            return jsonify({"error": "Dossier non trouve"}), 404

        return jsonify({
            "dossier_uuid": dossier_uuid,
            "ticket": json.loads(row[0] or "{}"),
            "analyse": json.loads(row[1] or "{}"),
            "rapport_client": json.loads(row[2] or "{}"),
            "rapport_avocat": json.loads(row[3] or "{}"),
            "procedure": json.loads(row[4] or "{}"),
            "points": json.loads(row[5] or "{}"),
            "lois": json.loads(row[6] or "[]"),
            "precedents": json.loads(row[7] or "[]"),
            "cross_verification": json.loads(row[8] or "{}"),
            "supervision": json.loads(row[9] or "{}"),
            "score_final": row[10],
            "confiance": row[11],
            "recommandation": row[12],
            "juridiction": row[13],
            "temps_total": row[14],
            "created_at": row[15]
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500


# ─── ENVOI EMAIL RAPPORT ──────────────────────
@app.route("/api/send-report", methods=["POST"])
def send_report():
    """Envoie le rapport par email a un destinataire"""
    data = request.get_json()
    if not data:
        return jsonify({"error": "JSON requis"}), 400

    email = data.get("email", "")
    dossier_uuid = data.get("dossier_uuid", "")

    if not email or not dossier_uuid:
        return jsonify({"error": "email et dossier_uuid requis"}), 400

    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()
        cur.execute("""SELECT rapport_client_json, score_final, recommandation
                     FROM analyses_completes WHERE dossier_uuid = %s""", (dossier_uuid,))
        row = cur.fetchone()
        conn.close()

        if not row:
            return jsonify({"error": f"Dossier {dossier_uuid} non trouve"}), 404

        rapport_client = row[0] if isinstance(row[0], dict) else json.loads(row[0] or "{}")
        rapport_client["score"] = row[1]

        from agents.agent_notification import AgentNotification
        notif = AgentNotification()
        result = notif.notifier(
            dossier_uuid,
            {"email": email},
            rapport_client
        )

        return jsonify({
            "success": result.get("email", {}).get("sent", False),
            "status": result.get("email", {}).get("status", "?"),
            "dossier_uuid": dossier_uuid,
            "email": email
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500


# ─── DEMO (test sans ticket reel) ────────────
@app.route("/api/demo", methods=["POST"])
def demo_analyze():
    """Retourne un resultat simule pour tester le frontend"""
    import random
    score = random.randint(62, 88)
    confiance = random.randint(75, 95)
    uuid_demo = f"DEMO{random.randint(1000,9999)}"
    return jsonify({
        "success": True,
        "dossier_uuid": uuid_demo,
        "score": score,
        "score_final": score,
        "confiance": confiance,
        "recommandation": "contester" if score >= 65 else "negocier",
        "juridiction": "QC",
        "temps": 45.2,
        "temps_total": 45.2,
        "nb_erreurs": 0,
        "phases": {
            "intake": {"lecteur": "OK", "ocr": "OK", "classificateur": "OK", "validateur": "OK", "routing": "OK"},
            "analyse": {"lois": "OK", "precedents": "OK", "analyste": "OK", "procedure": "OK", "points": "OK",
                        "temoignage": "OK", "photo": "OK", "lois_qc": "OK", "precedents_qc": "OK",
                        "analyste_qc": "OK", "procedure_qc": "OK", "lois_on": "SKIP", "precedents_on": "SKIP",
                        "analyste_on": "SKIP", "procedure_on": "SKIP"},
            "audit": {"verificateur": "OK", "cross_verification": "OK"},
            "livraison": {"rapport_client": "OK", "rapport_avocat": "OK", "notification": "OK", "supervision": "OK"}
        },
        "arguments": [
            "L'appareil de mesure (cinematometre laser) doit etre calibre quotidiennement selon le Manuel du fabricant — verifier le registre de calibration",
            "L'agent n'a pas precise dans son rapport la distance de captation — une mesure a plus de 300m est contestable (R. c. Beaulieu, 2019)",
            "La signalisation de la zone de vitesse reduite doit etre conforme aux normes MTQ — verifier la presence du panneau a l'entree de la zone",
            "Le delai entre la captation et l'interception est un facteur: un delai trop long empeche l'identification formelle du vehicule",
            "La marge d'erreur de +/- 2 km/h de l'appareil peut etre invoquee si l'exces est marginal"
        ],
        "supervision": {"score_qualite": 92, "decision": "APPROUVE", "agents_verifies": 26},
        "rapport_client": {
            "resume": "Votre contravention pour exces de vitesse presente plusieurs elements contestables. L'analyse de 26 agents IA specialises identifie 5 arguments de defense solides bases sur la jurisprudence quebecoise et les normes de calibration des appareils de mesure. Nous recommandons de contester cette infraction.",
            "verdict": "CONTESTER — Bonnes chances de reussite",
            "prochaines_etapes": [
                "Enregistrer votre plaidoyer de non-culpabilite au greffe de la cour municipale dans les 30 jours",
                "Demander la divulgation de la preuve (rapport d'infraction, registre de calibration, formation de l'agent)",
                "Preparer votre defense avec les arguments identifies ci-dessus",
                "Si possible, consulter un avocat specialise en droit routier pour maximiser vos chances"
            ]
        },
        "precedents_trouves": 8,
        "lois_trouvees": 4,
        "timestamp": datetime.now().isoformat()
    })


# ─── MONITORING / ADMIN DASHBOARD ─────────────
@app.route("/api/monitor")
def monitor():
    """Endpoint monitoring complet — DB, quota, pipeline, alertes"""
    try:
        conn = psycopg2.connect(**PG_CONFIG)
        cur = conn.cursor()

        # DB Stats
        tables_stats = {}
        for table in ['jurisprudence', 'lois_articles', 'analyses_completes',
                      'ref_jurisprudence_cle', 'jurisprudence_citations',
                      'jurisprudence_legislation', 'qc_radar_photo_lieux',
                      'mtl_collisions', 'qc_constats_infraction', 'qc_radar_photo_stats']:
            try:
                cur.execute(f"SELECT COUNT(*) FROM {table}")
                tables_stats[table] = cur.fetchone()[0]
            except Exception:
                conn.rollback()
                tables_stats[table] = -1

        # Jurisprudence breakdown
        cur.execute("SELECT database_id, COUNT(*) FROM jurisprudence GROUP BY database_id ORDER BY COUNT(*) DESC")
        par_tribunal = {row[0] or "N/A": row[1] for row in cur.fetchall()}

        cur.execute("SELECT resultat, COUNT(*) FROM jurisprudence GROUP BY resultat ORDER BY COUNT(*) DESC")
        par_resultat = {row[0] or "inconnu": row[1] for row in cur.fetchall()}

        cur.execute("SELECT province, COUNT(*) FROM jurisprudence GROUP BY province ORDER BY COUNT(*) DESC")
        par_province = {row[0] or "N/A": row[1] for row in cur.fetchall()}

        # Recent imports
        cur.execute("""SELECT date_decision, COUNT(*)
                      FROM jurisprudence
                      WHERE imported_at IS NOT NULL
                      GROUP BY date_decision ORDER BY date_decision DESC LIMIT 10""")
        recent_dates = {str(row[0]): row[1] for row in cur.fetchall()}

        # Analyses stats
        cur.execute("""SELECT COUNT(*), AVG(score_final), AVG(confiance), AVG(temps_total)
                      FROM analyses_completes""")
        a_row = cur.fetchone()
        analyses_stats = {
            "total": a_row[0] or 0,
            "score_moyen": round(float(a_row[1] or 0), 1),
            "confiance_moyenne": round(float(a_row[2] or 0), 1),
            "temps_moyen": round(float(a_row[3] or 0), 1)
        }

        cur.execute("""SELECT recommandation, COUNT(*)
                      FROM analyses_completes GROUP BY recommandation""")
        analyses_par_reco = {row[0] or "?": row[1] for row in cur.fetchall()}

        conn.close()

        # CanLII quota
        canlii_quota = {"remaining": "unknown", "daily_max": 4800}
        try:
            usage_file = "/var/www/aiticketinfo/logs/canlii_usage.json"
            if os.path.exists(usage_file):
                with open(usage_file) as f:
                    usage = json.load(f)
                canlii_quota = {
                    "used_today": usage.get("count", 0),
                    "remaining": 4800 - usage.get("count", 0),
                    "daily_max": 4800,
                    "last_reset": usage.get("date", "?")
                }
        except Exception:
            pass

        # Last import log
        last_import = "unknown"
        try:
            log_path = "/var/www/aiticketinfo/logs/canlii_import.log"
            if os.path.exists(log_path):
                with open(log_path) as f:
                    lines = f.readlines()
                    last_lines = [l.strip() for l in lines[-20:] if l.strip()]
                    last_import = "\n".join(last_lines)
        except Exception:
            pass

        # Alertes
        alertes = []
        if tables_stats.get('jurisprudence', 0) < 500:
            alertes.append({"level": "warning", "msg": f"Jurisprudence faible: {tables_stats.get('jurisprudence', 0)} dossiers (objectif: 20,000)"})
        if tables_stats.get('jurisprudence', 0) == 0:
            alertes.append({"level": "critical", "msg": "AUCUNE jurisprudence en DB!"})
        remaining = canlii_quota.get("remaining", 5000)
        if isinstance(remaining, int) and remaining <= 0:
            alertes.append({"level": "warning", "msg": "Quota CanLII epuise pour aujourd'hui"})
        if analyses_stats["total"] == 0:
            alertes.append({"level": "info", "msg": "Aucune analyse effectuee encore"})

        return jsonify({
            "status": "ok",
            "timestamp": datetime.now().isoformat(),
            "db": {
                "tables": tables_stats,
                "jurisprudence": {
                    "par_tribunal": par_tribunal,
                    "par_resultat": par_resultat,
                    "par_province": par_province,
                    "recent_dates": recent_dates
                }
            },
            "analyses": {
                "stats": analyses_stats,
                "par_recommandation": analyses_par_reco
            },
            "canlii": canlii_quota,
            "last_import_log": last_import[-500:] if isinstance(last_import, str) else last_import,
            "alertes": alertes,
            "cron": "0 1 * * * import_canlii_traffic.py --max-requests 4800"
        })
    except Exception as e:
        return jsonify({"status": "error", "error": str(e)}), 500


@app.route("/admin")
def admin_dashboard():
    """Dashboard admin — monitoring visuel"""
    return send_from_directory(".", "admin.html")


if __name__ == "__main__":
    print("FightMyTicket API v2 — 26 agents — http://0.0.0.0:8912")
    app.run(host="0.0.0.0", port=8912, debug=False)
